     1                                  ; Code generated by make ftoa.asm. DO NOT EDIT.
     2                                  
     3                                  ; Copyright 2022 Diamond Dinh (diamondburned), licensed under the MIT license.
     4                                  
     5                                  ; //Author information
     6                                  ; //  Author name: Timothy Vu
     7                                  ; //  Author email: timothy.vu@csu.fullerton.edu
     8                                  ; //  Author Section: M/W 2:00pm-3:50pm
     9                                  ; File name: ftoa.asm
    10                                  ; Language: Assembly (x86-64 NASM)
    11                                  ; Purpose: Convert a double-precision floating-point number to a null-terminated string.
    12                                  ; Input:
    13                                  ;   - RDI: Address of the double-precision number (num)
    14                                  ;   - RSI: Address of the character array (arr)
    15                                  ;   - RDX: Size of the character array (size)
    16                                  ; Output:
    17                                  ;   - The string representation of the number is written to `arr`.
    18                                  section .data
    19 00000000 303132333435363738-         digits db "0123456789", 0 ; Digits for conversion
    19 00000009 3900               
    20 0000000B 2E00                        point db ".", 0           ; Decimal point
    21                                      max_size equ 64           ; Maximum buffer size
    22 0000000D 0000000000002440            ten_double dq 10.0
    23                                  
    24                                  section .text
    25                                      global ftoa
    26                                  
    27                                  ftoa:
    28                                      ; Save caller's registers
    29 00000000 55                          push rbp
    30 00000001 4889E5                      mov rbp, rsp
    31 00000004 53                          push rbx
    32 00000005 51                          push rcx
    33 00000006 52                          push rdx
    34 00000007 56                          push rsi
    35 00000008 57                          push rdi
    36 00000009 4154                        push r12
    37 0000000B 4155                        push r13
    38 0000000D 4156                        push r14
    39 0000000F 4157                        push r15
    40                                  
    41                                      ; Input validation
    42 00000011 4885F6                      test rsi, rsi         ; Check if output buffer is null
    43 00000014 7476                        jz .return
    44 00000016 4885D2                      test rdx, rdx         ; Check if buffer size is zero
    45 00000019 7471                        jz .return
    46                                  
    47                                      ; Load the input double (num) into xmm0
    48 0000001B F20F1007                    movsd xmm0, [rdi]
    49                                  
    50                                      ; Check for negative numbers
    51 0000001F 660F57C9                    xorpd xmm1, xmm1
    52 00000023 660F2EC1                    ucomisd xmm0, xmm1
    53 00000027 7315                        jae .positive
    54                                  
    55                                      ; Handle negative numbers
    56 00000029 C6062D                      mov byte [rsi], '-'
    57 0000002C 48FFC6                      inc rsi
    58 0000002F 48FFCA                      dec rdx
    59 00000032 F20F100D(15000000)          movsd xmm1, [rel neg_mask]
    60 0000003A 660F57C1                    xorpd xmm0, xmm1
    61                                  
    62                                  .positive:
    63                                      ; Save base array pointer and buffer size
    64 0000003E 4989F4                      mov r12, rsi          ; Base array pointer
    65 00000041 4989D5                      mov r13, rdx          ; Remaining buffer size
    66                                  
    67                                      ; Integer part: convert and store
    68 00000044 F2480F2CD8                  cvttsd2si rbx, xmm0   ; Convert double to integer (truncates)
    69 00000049 4C89E1                      mov rcx, r12          ; Save current pointer for integer conversion
    70 0000004C E84A000000                  call convert_integer
    71                                  
    72                                      ; Add decimal point
    73 00000051 B82E000000                  mov rax, '.'
    74 00000056 41880424                    mov byte [r12], al
    75 0000005A 49FFC4                      inc r12
    76 0000005D 49FFCD                      dec r13
    77                                  
    78                                      ; Prepare for fractional part
    79 00000060 F20F100D(0D000000)          movsd xmm1, [rel ten_double]  ; xmm1 = 10.0
    80 00000068 F2480F2CC0                  cvttsd2si rax, xmm0
    81 0000006D F2480F2AD0                  cvtsi2sd xmm2, rax
    82 00000072 F20F5CC2                    subsd xmm0, xmm2    ; Get fractional part
    83 00000076 F20F59C1                    mulsd xmm0, xmm1    ; Scale up fractional part
    84 0000007A F2480F2CD8                  cvttsd2si rbx, xmm0 ; Convert to integer
    85 0000007F 4C89E1                      mov rcx, r12        ; Save current pointer
    86 00000082 E814000000                  call convert_integer
    87                                  
    88                                      ; Null-terminate the string
    89 00000087 41C6042400                  mov byte [r12], 0
    90                                  
    91                                  .return:
    92                                      ; Restore registers
    93 0000008C 415F                        pop r15
    94 0000008E 415E                        pop r14
    95 00000090 415D                        pop r13
    96 00000092 415C                        pop r12
    97 00000094 5F                          pop rdi
    98 00000095 5E                          pop rsi
    99 00000096 5A                          pop rdx
   100 00000097 59                          pop rcx
   101 00000098 5B                          pop rbx
   102 00000099 5D                          pop rbp
   103 0000009A C3                          ret
   104                                  
   105                                  convert_integer:
   106 0000009B 4989CE                      mov r14, rcx          ; Preserve original pointer
   107 0000009E 4889D8                      mov rax, rbx          ; Move number to rax for division
   108 000000A1 4D89EF                      mov r15, r13          ; Remaining buffer size
   109                                  
   110                                      ; Handle zero case
   111 000000A4 4885C0                      test rax, rax
   112 000000A7 750C                        jnz .integer_loop
   113                                  
   114 000000A9 41C6042430                  mov byte [r12], '0'
   115 000000AE 49FFC4                      inc r12
   116 000000B1 49FFCD                      dec r13
   117 000000B4 C3                          ret
   118                                  
   119                                  .integer_loop:
   120 000000B5 49FFCF                      dec r15               ; Decrement remaining size
   121 000000B8 741D                        jz .buffer_overflow   ; Exit if buffer is full
   122                                  
   123 000000BA BA00000000                  mov rdx, 0            ; Clear RDX (remainder)
   124 000000BF BB0A000000                  mov rbx, 10           ; Divisor
   125 000000C4 48F7F3                      div rbx               ; Divide RAX by 10
   126 000000C7 80C230                      add dl, '0'           ; Convert digit to ASCII
   127                                      
   128 000000CA 49FFCC                      dec r12               ; Move pointer back
   129 000000CD 41881424                    mov byte [r12], dl    ; Store digit
   130                                  
   131 000000D1 4885C0                      test rax, rax         ; Check if quotient is 0
   132 000000D4 75DF                        jnz .integer_loop
   133                                  
   134 000000D6 C3                          ret
   135                                  
   136                                  .buffer_overflow:
   137                                      ; Reset to original pointer and null-terminate
   138 000000D7 4D89F4                      mov r12, r14
   139 000000DA 41C6042400                  mov byte [r12], 0
   140 000000DF C3                          ret
   141                                  
   142                                  section .data
   143 00000015 0000000000000080            neg_mask dq 0x8000000000000000
